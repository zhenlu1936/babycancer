@inproceedings{bellard2005qemu,
author = {Bellard, Fabrice},
title = {QEMU, a fast and portable dynamic translator},
year = {2005},
publisher = {USENIX Association},
address = {USA},
abstract = {We present the internals of QEMU, a fast machine emulator using an original portable dynamic translator. It emulates several CPUs (x86, PowerPC, ARM and Sparc) on several hosts (x86, PowerPC, ARM, Sparc, Alpha and MIPS). QEMU supports full system emulation in which a complete and unmodified operating system is run in a virtual machine and Linux user mode emulation where a Linux process compiled for one target CPU can be run on another CPU.},
booktitle = {Proceedings of the Annual Conference on USENIX Annual Technical Conference},
pages = {41},
numpages = {1},
location = {Anaheim, CA},
series = {ATEC '05},
url = {https://www.usenix.org/legacy/events/usenix05/tech/freenix/bellard.html}
}

@article{aycock2003jit,
author = {Aycock, John},
title = {A brief history of just-in-time},
year = {2003},
issue_date = {June 2003},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {35},
number = {2},
issn = {0360-0300},
url = {https://doi.org/10.1145/857076.857077},
doi = {10.1145/857076.857077},
abstract = {Software systems have been using "just-in-time" compilation (JIT) techniques since the 1960s. Broadly, JIT compilation includes any translation performed dynamically, after a program has started execution. We examine the motivation behind JIT compilation and constraints imposed on JIT compilation systems, and present a classification scheme for such systems. This classification emerges as we survey forty years of JIT work, from 1960--2000.},
journal = {ACM Comput. Surv.},
month = jun,
pages = {97--113},
numpages = {17},
keywords = {Just-in-time compilation, dynamic compilation}
}

@INPROCEEDINGS{9251952,
  author={Jiang, Jinhu and Dong, Rongchao and Zhou, Zhongjun and Song, Changheng and Wang, Wenwen and Yew, Pen-Chung and Zhang, Weihua},
  booktitle={2020 53rd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)}, 
  title={More with Less – Deriving More Translation Rules with Less Training Data for DBTs Using Parameterization}, 
  year={2020},
  volume={},
  number={},
  pages={415-426},
  keywords={Training;Runtime;Microarchitecture;Emulation;Training data;Prototypes;Virtualization;DBT;Rule based;Parameterization},
  doi={10.1109/MICRO50266.2020.00043}}

@INPROCEEDINGS{10444850,
  author={Jiang, Jinhu and Liang, Chaoyi and Dong, Rongchao and Yang, Zhaohui and Zhou, Zhongjun and Wang, Wenwen and Yew, Pen-Chung and Zhang, Weihua},
  booktitle={2024 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)}, 
  title={A System-Level Dynamic Binary Translator Using Automatically-Learned Translation Rules}, 
  year={2024},
  volume={},
  number={},
  pages={423-434},
  keywords={Codes;Emulation;Prototypes;Switches;Virtual machining;Registers;Optimization},
  doi={10.1109/CGO57630.2024.10444850}}

@inproceedings{10.1145/3173162.3177160,
author = {Wang, Wenwen and McCamant, Stephen and Zhai, Antonia and Yew, Pen-Chung},
title = {Enhancing Cross-ISA DBT Through Automatically Learned Translation Rules},
year = {2018},
isbn = {9781450349116},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3173162.3177160},
doi = {10.1145/3173162.3177160},
abstract = {This paper presents a novel approach for dynamic binary translation (DBT) to automatically learn translation rules from guest and host binaries compiled from the same source code. The learned translation rules are then verified via binary symbolic execution and used in an existing DBT system, QEMU, to generate more efficient host binary code. Experimental results on SPEC CINT2006 show that the average time of learning a translation rule is less than two seconds. With the rules learned from a collection of benchmark programs excluding the targeted program itself, an average 1.25X performance speedup over QEMU can be achieved for SPEC CINT2006. Moreover, the translation overhead introduced by this rule-based approach is very small even for short-running workloads.},
booktitle = {Proceedings of the Twenty-Third International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {84–97},
numpages = {14},
keywords = {DBT, rule learning, symbolic execution},
location = {Williamsburg, VA, USA},
series = {ASPLOS '18}
}

@inproceedings{10.1145/3567955.3567962,
author = {Gouicem, Redha and Sprokholt, Dennis and Ruehl, Jasper and Rocha, Rodrigo C. O. and Spink, Tom and Chakraborty, Soham and Bhatotia, Pramod},
title = {Risotto: A Dynamic Binary Translator for Weak Memory Model Architectures},
year = {2022},
isbn = {9781450399159},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3567955.3567962},
doi = {10.1145/3567955.3567962},
abstract = {Dynamic Binary Translation (DBT) is a powerful approach to support cross-architecture emulation of unmodified binaries. However, DBT systems face correctness and performance challenges, when emulating concurrent binaries from strong to weak memory consistency architectures. As a matter of fact, we report several translation errors in QEMU, when emulating x86 binaries on Arm hosts. To address these challenges, we propose an end-to-end approach that provides correct and efficient emulation for weak memory model architectures. Our contributions are twofold: we formalize QEMU’s intermediate representation’s memory model, and use it to propose formally verified mapping schemes to bridge the strong-on-weak memory consistency mismatch. Secondly, we implement these verified mappings in Risotto, a QEMU-based DBT system that optimizes memory fence placement while ensuring correctness. Risotto further enhances the emulation performance via cross-architecture dynamic linking of native shared libraries, and fast and correct translation of compare-and-swap operations. We evaluate Risotto using multi-threaded benchmark suites and real-world applications, and show that Risotto improves the emulation performance by 6.7\% on average over ”erroneous” QEMU, while ensuring correctness.},
booktitle = {Proceedings of the 28th ACM International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 1},
pages = {107–122},
numpages = {16},
keywords = {Binary translation, formal verification, memory models},
location = {Vancouver, BC, Canada},
series = {ASPLOS 2023}
}

@inproceedings{10.5555/3691992.3692054,
author = {Gao, Chen and Meng, Xiangwei and Li, Wei and Lai, Jinhui and Zhang, Yiran and Ren, Fengyuan},
title = {CrossMapping: harmonizing memory consistency in cross-ISA binary translation},
year = {2024},
isbn = {978-1-939133-41-0},
publisher = {USENIX Association},
address = {USA},
abstract = {The increasing prevalence of new Instruction Set Architectures (ISAs) necessitates the migration of closed-source binary programs across ISAs. Dynamic Binary Translation (DBT) stands out as a crucial technology for the cross-ISA emulation of binary programs. However, due to the mismatch in memory consistency between guest ISA and host ISA, DBT systems face substantial challenges in guaranteeing correctness and translation performance for concurrent programs. Despite several attempts to bridge the memory inconsistency between guest and host ISA, prior work is either not universal for cross-ISA DBT systems or inefficient and even error-prone in translation.This work presents CrossMapping, a general primitive mapping framework to enhance existing DBT systems for cross-ISA translation. By harmonizing memory consistency across diverse ISAs, CrossMapping enables smooth cross-ISA translation and accomplishes correct emulation. CrossMapping introduces specification tables to describe memory models in a unified and precise format, which facilitates the derivation of concurrent primitive mapping schemes based on a convenient comparison and analysis of memory models. The correctness of cross-ISA emulation is guaranteed by harmoniously integrating the derived mapping schemes with existing DBT systems. We evaluate CrossMapping for x86, ARMv8, and RISC-V on top of QEMU using the PARSEC benchmark suite. The results show that the average performance improvement can reach 8.5\% when emulating x86 on ARMv8 and 7.3\% when emulating x86 on RISC-V.},
booktitle = {Proceedings of the 2024 USENIX Conference on Usenix Annual Technical Conference},
articleno = {62},
numpages = {16},
location = {Santa Clara, CA, USA},
series = {USENIX ATC'24}
}

@inproceedings{10.5555/3768039.3768097,
author = {Zur, Ori Ben and Krebs, Jakob and Bergman, Shai Aviram and Silberstein, Mark},
title = {Accelerating nested virtualization with HyperTurtle},
year = {2025},
isbn = {978-1-939133-48-9},
publisher = {USENIX Association},
address = {USA},
abstract = {Nested virtualization provides strong isolation but incurs non-trivial performance costs. Prior works alleviate some overheads but suffer from limitations such as intrusive code changes or reduced control over nested virtual environments. We present HyperTurtle, a general approach to accelerate nested virtualization. It reduces the number of costly world switches between the virtualization layers, the primary source of performance overheads. HyperTurtle offloads the execution of certain parts on the critical path of the virtualized hypervisor, encapsulating them as eBPF programs and executing them safely in the context of the bare-metal hypervisor. Thus, HyperTurtle reduces the performance cost of world switches whilst retaining control over nested VMs. We show that HyperTurtle can be used to optimize a variety of OS subsystems and apply it to memory management, networking, and application profiling. HyperTurtle achieves significant performance improvements in micro and macro-benchmarks, for example, 5\texttimes{} faster EPT fault handling, which translates to up to 27\% faster boot-time of Kata containers, without requiring intrusive code changes to the virtualization infrastructure.},
booktitle = {Proceedings of the 2025 USENIX Conference on Usenix Annual Technical Conference},
articleno = {58},
numpages = {16},
location = {Boston, MA, USA},
series = {USENIX ATC '25}
}